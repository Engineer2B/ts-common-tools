import * as fs from "fs";
import * as path from "path";
import { ArrayTool } from "./ArrayTool";
import { StringTool } from "./StringTool";

/**
 * For inferring basic type definitions of a javascript object.
 * Example usage:
 * var moduleName = '\'https\'';
 * var objectName = 'HttpsRequestResult';
 * var theTypingsInferer = new TypingsInferer(
 *                           myDirectories.thisDirPlus([
 *                           'TypeScripts',
 *                           'Typings',
 *                           'Autogenerated'])
 *                           , objectName + '.d.ts',
 *                           moduleName);
 * theTypingsInferer.write(res, 'HttpsRequestResult');
 */
export class TypingsInferer {
	private moduleName: string;

	/**
	 * List of objects that have been generated already.
	 */
	private objectCache: { jsObject: any, outputName: string }[];

	/**
	 *  Initializes a new instance of the TypingsInferer class.
	 * @param {string} outputPath The path where the file is saved to.
	 * @param {string} moduleName The name of the module.
	 * @param {Dictionary} replacementDictionary A dictionary of key value pairs.
	 */
	private constructor(
		public outputPath: string,
		moduleName: string,
		modulePostFix: string,
		public replacementDictionary: { [index: string]: string }) {
		this.moduleName = `${moduleName}${modulePostFix}`;
		this.objectCache = [];
	}

	public static New(qRaw: boolean, moduleName: string, outputPath: string, replacementDictionary: { [index: string]: string }): TypingsInferer {
		return new TypingsInferer(
			outputPath,
			moduleName,
			qRaw ? ".raw" : "",
			replacementDictionary);
	}

	/**
	 * Writes a typings file for a JSON request object.
	 * @param {any} object The input object.
	 * @param {string} objectName The name of the object.
	 * @param {string} resultName When it's a query, the result
	 * @param {boolean} qRaw Whether the object requires further parsing.
	 * @param {ExchangeEnum} exchange The exchange for which the typings are written.
	 * @param {{ [index: string]: string }} [replacementDictionary={ Result: resultName }] A replacement dictionary, where each entry has the first letter capitalized.
	 */
	public static WriteTypings(
		object: any,
		objectName: string,
		moduleName: string,
		outputPath: string,
		resultName: string,
		qRaw: boolean,
		replacementDictionary: { [index: string]: string } = { Result: resultName }): void {
		objectName = qRaw ? `${objectName}Raw` : objectName;
		const theTypingsInferer = TypingsInferer.New(qRaw, moduleName, outputPath, replacementDictionary);
		theTypingsInferer.WriteToStream(object, objectName);
	}


	/**
 * Writes an object to a file, if the object has been written before, it will not be written.
 * @param {any} jsObject Any javascript object.
 * @param {string} outputName The output name.
 * @returns {string} The actual output name.
 */
	public WriteToStream(
		jsObject: any,
		outputName: string): string {
		if (this.objectCache.some((cachedObject: { jsObject: any, outputName: string }) => {
			if (TypingsInferer.objectSimilar(cachedObject.jsObject, jsObject)) {
				outputName = cachedObject.outputName;

				return true;
			} else {
				return false;
			}
		})) {
			// Exit prematurely.
			return outputName;
		} else {
			this.objectCache.push({ jsObject: jsObject, outputName: outputName });
		}
		const stream = this.createStream(outputName);
		stream.write("declare module " +
			this.moduleName +
			" {\n");
		stream.write("\texport interface " +
			"I" + outputName +
			" {\n");
		this.writeProps(jsObject, stream);
		stream.write("}");
		stream.end();

		return outputName;
	}

	private static typeSwitch(typeName: string): string {
		switch (typeName) {
			case "function":
				return "Function";
			default:
				return typeName;
		}
	}

	/**
	 * Checks if objects have equal property names and types.
	 * @param {any} object1 The first object.
	 * @param {any} object2 The second object.
	 * @returns {boolean} Whether the objects are similar.
	 */
	private static objectSimilar(object1: any, object2: any): boolean {
		const object1Names = ArrayTool.Sort_object(object1);
		const object2Names = ArrayTool.Sort_object(object2);
		if (object1Names.length !== object2Names.length) {

			return false;
		} else {
			for (let index = 0; index < object1Names.length; index++) {
				if (object1Names[index] !== object2Names[index]) {

					return false;
				}
			}

			return true;
		}
	}

	private createStream(
		outputName: string): fs.WriteStream {
		const fileName = path.join.apply(undefined, [this.outputPath, `I${outputName}.d.ts`]);
		const stream = fs.createWriteStream(fileName, {encoding: "utf-8"});
		stream.on("finish",
			() => {
				console.log('The file "' + outputName +
					'.d.ts" was saved to "' + this.outputPath + '"!');
			});

		return stream;
	}

	private writeProps(jsObject: any, stream: fs.WriteStream) {
		let typeName = "";
		let writeString: string;
		// ReSharper disable once MissingHasOwnPropertyInForeach
		// tslint:disable-next-line:forin
		for (const property in jsObject) {
			const theObject = jsObject[property];
			typeName = typeof theObject;
			if (typeName === "object") {
				if (Object.getOwnPropertyNames(jsObject).length === 0) {
					writeString = `\t\t${property}: any;\n`;
					stream.write(writeString);
				} else {
					this.writeObject(theObject, property, stream, jsObject);
				}
			} else if (typeName === "undefined") {
				continue;
			} else {
				writeString = `\t\t${property}: ${TypingsInferer.typeSwitch(typeof jsObject[property])};\n`;
				stream.write(writeString);
			}
		}
		stream.write("\t}\n");
	}

	private writeObject(
		theObject: any,
		property: any,
		stream: fs.WriteStream,
		jsObject: any) {
		let writeString: string;
		let newOutputName: string;
		if (theObject === null) {
			writeString = `\t\t${property}: any;\n`;
			stream.write(writeString);
		} else if (theObject.constructor === undefined) {
			writeString = `\t\t${property}: any;\n`;
			stream.write(writeString);
		} else if (theObject.hasOwnProperty("length")) {
			newOutputName = StringTool.Cap1(property);
			newOutputName = StringTool.CheckReplace(
				newOutputName,
				this.replacementDictionary);
			if (theObject.length > 0) {
				newOutputName = this.WriteToStream(theObject[0], newOutputName);
				writeString = `\t\t${property}: I${newOutputName}[];\n`;
				stream.write(writeString);
			} else {
				writeString = `\t\t${property}: any[];\n`;
				stream.write(writeString);
			}
		} else {
			newOutputName = StringTool.Cap1(property);
			newOutputName = StringTool.CheckReplace(
				newOutputName,
				this.replacementDictionary);
			newOutputName = newOutputName.replace(/\/+/g, "-");
			newOutputName = this.WriteToStream(jsObject[property], newOutputName);
			writeString = `\t\t${property}: I${newOutputName};\n`;
			stream.write(writeString);
		}
	}
}
